import bpy
import socket
import threading
from mathutils import Quaternion

UDP_IP = "0.0.0.0"
UDP_PORT = 8080
ARMATURE_NAME = "metarig"

SENSOR_CONFIG = {
    0: { 
        "bone": "upper_arm.L",
        "order": [0, 1, 3, 2],  
        "signs": [1, 1, 1, -1]  
    },
    1: { 
        "bone": "forearm.L",
        "order": [0, 1, 3, 2],
        "signs": [1, 1, 1, -1]
    },
    2: { 
        "bone": "hand.L",
        "order": [0, 1, 3, 2],
        "signs": [1, 1, 1, -1]
    }
}

shared_data = {"raw": {}, "offset": {}, "running": False}

def udp_server():
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((UDP_IP, UDP_PORT))
    sock.setblocking(0)
    
    print("--- SERVER START (Low Latency Mode) ---")
    
    while shared_data["running"]:
        try:
            
            data = None
            while True:
                try:
                    chunk, _ = sock.recvfrom(1024)
                    data = chunk
                except BlockingIOError:
                    break 
            
            if data:
                line = data.decode('utf-8').strip()
                parts = line.split(',')
                if len(parts) == 5:
                    idx = int(parts[0])
                    # w, x, y, z
                    q = [float(parts[1]), float(parts[2]), float(parts[3]), float(parts[4])]
                    shared_data["raw"][idx] = q
        except Exception:
            pass 
            
    sock.close()

class MocapOp(bpy.types.Operator):
    bl_idname = "wm.mocap_udp"
    bl_label = "Start Mocap UDP"
    _timer = None

    def modal(self, context, event):
        if event.type == 'ESC': return self.cancel(context)
        
        
        if event.type == 'F9' and event.value == 'PRESS':
            print(">>> CALIBRATING...")
            for i in shared_data["raw"]:
               
                q_raw = Quaternion(shared_data["raw"][i])
                
               
                if i in SENSOR_CONFIG:
                    cfg = SENSOR_CONFIG[i]
                    o, s = cfg["order"], cfg["signs"]
                    q_mapped = Quaternion((q_raw[o[0]]*s[0], q_raw[o[1]]*s[1], q_raw[o[2]]*s[2], q_raw[o[3]]*s[3]))
                    shared_data["offset"][i] = q_mapped.conjugated()

        if event.type == 'TIMER':
            obj = bpy.data.objects.get(ARMATURE_NAME)
            if obj:
                for idx, cfg in SENSOR_CONFIG.items():
                    if idx in shared_data["raw"]:
                        bone = obj.pose.bones.get(cfg["bone"])
                        if bone:
                            raw = shared_data["raw"][idx]
                            
                          
                            o, s = cfg["order"], cfg["signs"]
                            q_mapped = Quaternion((
                                raw[o[0]]*s[0], raw[o[1]]*s[1], 
                                raw[o[2]]*s[2], raw[o[3]]*s[3]
                            ))
                            
                          
                            offset = shared_data["offset"].get(idx, Quaternion((1,0,0,0)))
                            bone.rotation_quaternion = offset @ q_mapped
            return {'PASS_THROUGH'}
        return {'PASS_THROUGH'}

    def execute(self, context):
        if shared_data["running"]: return {'FINISHED'}
        shared_data["running"] = True
        threading.Thread(target=udp_server, daemon=True).start()
       
        self._timer = context.window_manager.event_timer_add(0.01, window=context.window)
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}

    def cancel(self, context):
        shared_data["running"] = False
        context.window_manager.event_timer_remove(self._timer)
        return {'CANCELLED'}

def register(): bpy.utils.register_class(MocapOp)
def unregister(): bpy.utils.unregister_class(MocapOp)

if __name__ == "__main__":
    register()
    bpy.ops.wm.mocap_udp()